#Multi_Power_Cycle configure using List


import sys
import pandas as pd
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QPushButton, QMessageBox, QLineEdit,
    QComboBox, QTextEdit, QHBoxLayout, QGroupBox,
    QFormLayout, QSpinBox, QTableWidget, QTableWidgetItem
)
from PyQt5.QtCore import QTimer, QDateTime
import pyvisa


class PowerSupplyGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Smart Power Supply Controller with Sequence")
        self.setGeometry(300, 300, 700, 600)

        self.layout = QVBoxLayout()

        # --- COM Port Selection ---
        self.port_dropdown = QComboBox()
        self.refresh_ports()

        # --- Voltage and Current Input (manual configure only) ---
        self.voltage_input = QLineEdit()
        self.voltage_input.setPlaceholderText("Enter Voltage (e.g. 22.0)")
        self.current_input = QLineEdit()
        self.current_input.setPlaceholderText("Enter Current (e.g. 2.0)")

        # --- Info and Output Labels ---
        self.info_label = QLabel("Status: Not Connected")
        self.volt_label = QLabel("Measured Voltage: N/A")
        self.curr_label = QLabel("Measured Current: N/A")

        # --- Log Area ---
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setPlaceholderText("Command log...")

        # --- Buttons ---
        self.connect_button = QPushButton("Connect")
        self.config_button = QPushButton("Configure Power Supply")
        self.disconnect_button = QPushButton("Disconnect")
        self.start_log_button = QPushButton("Start Logging")
        self.stop_log_button = QPushButton("Stop Logging")

        # --- Sequence Controls ---
        seq_group = QGroupBox("Cycle Sequence Configuration")
        seq_layout = QVBoxLayout()

        self.sequence_table = QTableWidget(0, 4)
        self.sequence_table.setHorizontalHeaderLabels(["Voltage (V)", "Current (A)", "ON Time (s)", "OFF Time (s)"])
        self.sequence_table.horizontalHeader().setStretchLastSection(True)

        self.add_cycle_button = QPushButton("Add Cycle")
        self.remove_cycle_button = QPushButton("Remove Selected Cycle")
        self.repeat_input = QSpinBox()
        self.repeat_input.setRange(1, 1000000)
        self.repeat_input.setValue(1)
        self.start_seq_button = QPushButton("Start Sequence")
        self.stop_seq_button = QPushButton("Stop Sequence")
        self.stop_seq_button.setEnabled(False)

        btn_h = QHBoxLayout()
        btn_h.addWidget(self.add_cycle_button)
        btn_h.addWidget(self.remove_cycle_button)

        seq_layout.addWidget(self.sequence_table)
        seq_layout.addLayout(btn_h)
        seq_layout.addWidget(QLabel("Repeat Sequence (times):"))
        seq_layout.addWidget(self.repeat_input)
        seq_layout.addWidget(self.start_seq_button)
        seq_layout.addWidget(self.stop_seq_button)

        seq_group.setLayout(seq_layout)

        # --- Button Actions ---
        self.connect_button.clicked.connect(self.connect_to_supply)
        self.config_button.clicked.connect(self.configure_supply)
        self.disconnect_button.clicked.connect(self.disconnect_supply)
        self.start_log_button.clicked.connect(self.start_logging)
        self.stop_log_button.clicked.connect(self.stop_logging)
        self.add_cycle_button.clicked.connect(self.add_cycle)
        self.remove_cycle_button.clicked.connect(self.remove_cycle)
        self.start_seq_button.clicked.connect(self.start_sequence)
        self.stop_seq_button.clicked.connect(self.stop_sequence)

        # --- Add widgets to layout ---
        self.layout.addWidget(QLabel("Select COM Port:"))
        self.layout.addWidget(self.port_dropdown)

        form_h = QHBoxLayout()
        left_v = QVBoxLayout()
        right_v = QVBoxLayout()
        left_v.addWidget(self.voltage_input)
        left_v.addWidget(self.current_input)
        left_v.addWidget(self.info_label)
        left_v.addWidget(self.volt_label)
        left_v.addWidget(self.curr_label)

        right_v.addWidget(self.connect_button)
        right_v.addWidget(self.config_button)
        right_v.addWidget(self.start_log_button)
        right_v.addWidget(self.stop_log_button)
        right_v.addWidget(self.disconnect_button)

        form_h.addLayout(left_v)
        form_h.addLayout(right_v)

        self.layout.addLayout(form_h)
        self.layout.addWidget(seq_group)
        self.layout.addWidget(QLabel("Log Output:"))
        self.layout.addWidget(self.log_output)

        self.setLayout(self.layout)

        # --- VISA handles ---
        self.rm = None
        self.power_supply = None

        # --- Timer and Logging ---
        self.timer = QTimer()
        self.timer.timeout.connect(self.log_measurements)
        self.data_log = pd.DataFrame(columns=["Timestamp", "Voltage (V)", "Current (A)"])

        # --- Sequence execution state ---
        self.seq_timer = QTimer()
        self.seq_timer.setSingleShot(True)
        self.seq_timer.timeout.connect(self._seq_timer_timeout)
        self.seq_running = False
        self.seq_data = []
        self.seq_index = 0
        self.seq_repeat = 0
        self.seq_done = 0
        self.seq_phase = None  # "ON" or "OFF"

    # -------------------------
    # Utility
    # -------------------------
    def refresh_ports(self):
        try:
            rm = pyvisa.ResourceManager()
            ports = rm.list_resources()
            self.port_dropdown.clear()
            self.port_dropdown.addItems(ports)
        except Exception as e:
            QMessageBox.critical(self, "Error listing COM ports", str(e))

    def log(self, message: str):
        timestamp = QDateTime.currentDateTime().toString("yyyy-MM-dd HH:mm:ss")
        self.log_output.append(f"[{timestamp}] {message}")

    # -------------------------
    # Connection / Commands
    # -------------------------
    def connect_to_supply(self):
        try:
            selected_port = self.port_dropdown.currentText()
            if not selected_port:
                QMessageBox.warning(self, "No Port", "Select a COM/ VISA resource first.")
                return
            self.rm = pyvisa.ResourceManager()
            self.power_supply = self.rm.open_resource(selected_port, open_timeout=10000)
            self.write_command("SYST:REM")

            idn = self.query_command("*IDN?")
            self.info_label.setText(f"Connected: {idn.strip()}")
            self.log(f"Connected to: {idn.strip()}")
        except Exception as e:
            QMessageBox.critical(self, "Connection Error", str(e))
            self.log(f"Connection Error: {str(e)}")

    def configure_supply(self):
        if self.power_supply:
            try:
                voltage = self.voltage_input.text().strip()
                current = self.current_input.text().strip()

                if not voltage or not current:
                    QMessageBox.warning(self, "Input Error", "Enter both voltage and current.")
                    return

                self.write_command("OUTP OFF")
                self.write_command(f"VOLT {voltage}")
                self.write_command(f"CURR {current}")
                self.write_command("OUTP ON")

                voltage = self.query_command("MEAS:VOLT?").strip()
                current = self.query_command("MEAS:CURR?").strip()

                self.volt_label.setText(f"Measured Voltage: {voltage} V")
                self.curr_label.setText(f"Measured Current: {current} A")
                self.log(f"Configured: {voltage} V, {current} A")
            except Exception as e:
                QMessageBox.warning(self, "Command Error", str(e))
                self.log(f"Command Error: {str(e)}")
        else:
            QMessageBox.warning(self, "Warning", "Not connected to power supply.")
            self.log("Configure failed: No connection.")

    def disconnect_supply(self):
        if self.power_supply:
            try:
                if self.seq_running:
                    self.stop_sequence()
                if self.timer.isActive():
                    self.stop_logging()

                self.write_command("OUTP OFF")
                self.power_supply.close()
                self.power_supply = None
                self.info_label.setText("Disconnected")
                self.volt_label.setText("Measured Voltage: N/A")
                self.curr_label.setText("Measured Current: N/A")
                self.log("Disconnected from power supply.")
            except Exception as e:
                QMessageBox.warning(self, "Disconnection Error", str(e))
                self.log(f"Disconnection Error: {str(e)}")

    # -------------------------
    # Logging (measurements)
    # -------------------------
    def start_logging(self):
        if self.power_supply:
            self.data_log = pd.DataFrame(columns=["Timestamp", "Voltage (V)", "Current (A)"])
            self.timer.start(1000)  # Log every 1 second
            self.log("Started logging measurements...")
        else:
            QMessageBox.warning(self, "Warning", "Connect to power supply first.")
            self.log("Start Logging failed: No connection.")

    def stop_logging(self):
        if self.timer.isActive():
            self.timer.stop()
        try:
            self.data_log.to_csv("Power_Log.csv", index=False)
            self.log("Stopped logging. Data saved to Power_Log.csv")
        except Exception as e:
            self.log(f"Error saving log: {str(e)}")

    def log_measurements(self):
        if not self.power_supply:
            self.log("Logging Error: No connection.")
            return
        try:
            voltage = float(self.query_command("MEAS:VOLT?").strip())
            current = float(self.query_command("MEAS:CURR?").strip())
            timestamp = QDateTime.currentDateTime().toString("yyyy-MM-dd HH:mm:ss")

            self.volt_label.setText(f"Measured Voltage: {voltage} V")
            self.curr_label.setText(f"Measured Current: {current} A")

            new_row = {"Timestamp": timestamp, "Voltage (V)": voltage, "Current (A)": current}
            self.data_log = pd.concat([self.data_log, pd.DataFrame([new_row])], ignore_index=True)
        except Exception as e:
            self.log(f"Logging Error: {str(e)}")

    # -------------------------
    # Low-level instrument I/O
    # -------------------------
    def write_command(self, cmd: str):
        if not self.power_supply:
            raise RuntimeError("No instrument connected")
        self.power_supply.write(cmd)
        self.log(f"> {cmd}")

    def query_command(self, cmd: str) -> str:
        if not self.power_supply:
            raise RuntimeError("No instrument connected")
        response = self.power_supply.query(cmd)
        self.log(f"> {cmd}\n< {response.strip()}")
        return response

    # -------------------------
    # Sequence Management
    # -------------------------
    def add_cycle(self):
        row = self.sequence_table.rowCount()
        self.sequence_table.insertRow(row)
        # Default values
        self.sequence_table.setItem(row, 0, QTableWidgetItem("5"))
        self.sequence_table.setItem(row, 1, QTableWidgetItem("1"))
        self.sequence_table.setItem(row, 2, QTableWidgetItem("5"))
        self.sequence_table.setItem(row, 3, QTableWidgetItem("5"))

    def remove_cycle(self):
        selected = self.sequence_table.currentRow()
        if selected >= 0:
            self.sequence_table.removeRow(selected)

    def start_sequence(self):
        if not self.power_supply:
            QMessageBox.warning(self, "Warning", "Connect to power supply first.")
            self.log("Start Sequence failed: No connection.")
            return

        # Read cycles from table
        self.seq_data = []
        for row in range(self.sequence_table.rowCount()):
            try:
                v = float(self.sequence_table.item(row, 0).text())
                c = float(self.sequence_table.item(row, 1).text())
                on = float(self.sequence_table.item(row, 2).text())
                off = float(self.sequence_table.item(row, 3).text())
                self.seq_data.append({"v": v, "c": c, "on": on, "off": off})
            except Exception:
                QMessageBox.warning(self, "Input Error", f"Invalid entry in row {row+1}")
                return

        if not self.seq_data:
            QMessageBox.warning(self, "Input Error", "Add at least one cycle step.")
            return

        self.seq_repeat = self.repeat_input.value()
        self.seq_done = 0
        self.seq_index = 0
        self.seq_running = True
        self.seq_phase = None
        self.start_seq_button.setEnabled(False)
        self.stop_seq_button.setEnabled(True)

        self.log(f"Starting sequence with {len(self.seq_data)} steps, repeating {self.seq_repeat} times.")
        self._start_next_cycle()

    def stop_sequence(self):
        self.seq_timer.stop()
        self.seq_running = False
        self.seq_phase = None
        self.start_seq_button.setEnabled(True)
        self.stop_seq_button.setEnabled(False)
        self.log("Sequence stopped by user.")

    def _start_next_cycle(self):
        if not self.seq_running:
            return

        if self.seq_index >= len(self.seq_data):
            self.seq_done += 1
            if self.seq_done >= self.seq_repeat:
                self.write_command("OUTP OFF")
                self.log("Sequence completed.")
                self.stop_sequence()
                return
            else:
                self.seq_index = 0

        cycle = self.seq_data[self.seq_index]
        self.write_command("OUTP OFF")
        self.write_command(f"VOLT {cycle['v']}")
        self.write_command(f"CURR {cycle['c']}")
        self.log(f"Starting step {self.seq_index+1}: {cycle['v']}V, {cycle['c']}A, ON {cycle['on']}s / OFF {cycle['off']}s")
        self.seq_phase = "ON"
        self.write_command("OUTP ON")
        self.seq_timer.start(int(cycle["on"]*1000))

    def _seq_timer_timeout(self):
        if not self.seq_running:
            return
        cycle = self.seq_data[self.seq_index]

        if self.seq_phase == "ON":
            self.write_command("OUTP OFF")
            self.seq_phase = "OFF"
            self.seq_timer.start(int(cycle["off"]*1000))
            self.log(f"Step {self.seq_index+1}: OFF for {cycle['off']}s")
        elif self.seq_phase == "OFF":
            self.seq_index += 1
            self._start_next_cycle()

    # -------------------------
    # Cleanup
    # -------------------------
    def closeEvent(self, event):
        if self.seq_running:
            self.stop_sequence()
        if self.timer.isActive():
            self.stop_logging()
        try:
            if self.power_supply:
                self.write_command("OUTP OFF")
                self.power_supply.close()
        except Exception:
            pass
        event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PowerSupplyGUI()
    window.show()
    sys.exit(app.exec_())
